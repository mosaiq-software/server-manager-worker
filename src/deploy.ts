import { DeployableProject, DeploymentState } from '@mosaiq/nsm-common/types';
import { execOnHost, execSafe } from './execUtils';
import * as fs from 'fs/promises';
import { getGitHttpsUri, getGitSshUri } from '@mosaiq/nsm-common/gitUtils';
import { sendLogToControlPlane } from './controlPlane';

export const deployProject = async (deployable: DeployableProject) => {
    try {
        await cloneRepository(deployable);

        await injectDotenv(deployable.projectId, deployable.dotenv, deployable.logId);
        await runDeploymentCommand(deployable.projectId, deployable.runCommand, deployable.timeout, deployable.logId);
        await sendLogToControlPlane(deployable.logId, 'Deployment steps completed successfully.\n', DeploymentState.DEPLOYED);
    } catch (error: any) {
        await sendLogToControlPlane(deployable.logId, `Failed to deploy project: ${error.message}\n`, DeploymentState.FAILED);
        console.error('Failed to deploy project:', error);
    }
};

const cloneRepository = async (deployable: DeployableProject): Promise<void> => {
    const repoPath = `${process.env.DEPLOYMENT_PATH}/${deployable.projectId}`;
    const branchFlags = deployable.repoBranch ? `-b ${deployable.repoBranch} --single-branch` : '';

    try {
        await sendLogToControlPlane(deployable.logId, 'Cleaning up old repository...\n', DeploymentState.DEPLOYING);
        await fs.rm(repoPath, { recursive: true, force: true });
    } catch (e: any) {
        throw new Error(`Error cleaning up old repository: ${e.message}`);
    }

    if (process.env.PRODUCTION !== 'true') {
        console.log('Not in production mode, handling local repository clone');
        await sendLogToControlPlane(deployable.logId, 'Not in production mode, handling local repository clone\n', DeploymentState.DEPLOYING);
        const httpUri = getGitHttpsUri(deployable.repoOwner, deployable.repoName);
        const cmd = `git clone ${branchFlags} ${httpUri} ${repoPath}`;
        console.log('Cloning repository with command:', cmd);
        const { out: gitOut, code: gitCode } = await execSafe(cmd, 1000 * 60 * 1);
        if (gitCode !== 0) {
            console.error('Git clone output:', gitOut);
            throw new Error(`Git clone exited with code ${gitCode}`);
        }
        await sendLogToControlPlane(deployable.logId, `Git clone output:\n${gitOut}\n`, DeploymentState.DEPLOYING);
        return;
    }

    try {
        const gitSshUri = getGitSshUri(deployable.repoOwner, deployable.repoName);
        const sshFlags = `-c core.sshCommand="/usr/bin/ssh -i ${process.env.GIT_SSH_KEY_DIR}/${process.env.GIT_SSH_KEY_FILE}"`;
        const cmd = `git clone --progress ${branchFlags} ${sshFlags} ${gitSshUri} ${repoPath}`;
        await sendLogToControlPlane(deployable.logId, `Cloning repository ${gitSshUri}...\n`, DeploymentState.DEPLOYING);
        const { out: gitOut, code: gitCode } = await execSafe(cmd, 1000 * 60 * 5);
        if (gitCode !== 0) {
            await sendLogToControlPlane(deployable.logId, `Git clone output:\n${gitOut}\n`, DeploymentState.DEPLOYING);
            throw new Error(`Git clone exited with code ${gitCode}`);
        }
        await sendLogToControlPlane(deployable.logId, `Git clone output:\n${gitOut}\n`, DeploymentState.DEPLOYING);
        return;
    } catch (e: any) {
        throw new Error(`Error cloning repository: ${e.message}`);
    }
};

const injectDotenv = async (projectId: string, dotenv: string, logId: string): Promise<void> => {
    if (process.env.PRODUCTION !== 'true') {
        console.log('Not in production mode, skipping dotenv injection');
        await sendLogToControlPlane(logId, 'Not in production mode, skipping dotenv injection\n', DeploymentState.DEPLOYING);
        return;
    }

    try {
        const dotenvWithHeader = `# Generated by NSM - Do not edit directly\n${dotenv}`;
        await fs.writeFile(`${process.env.DEPLOYMENT_PATH}/${projectId}/.env`, dotenvWithHeader);
        await sendLogToControlPlane(logId, 'Successfully injected dotenv file\n', DeploymentState.DEPLOYING);
    } catch (e: any) {
        throw new Error(`Error injecting dotenv file: ${e.message}`);
    }
};

const runDeploymentCommand = async (projectId: string, runCommand: string, timeoutms: number, logId: string): Promise<void> => {
    if (process.env.PRODUCTION !== 'true') {
        console.log('Not in production mode, skipping deployment execution');
        await sendLogToControlPlane(logId, 'Not in production mode, skipping deployment execution\n', DeploymentState.DEPLOYING);
        return;
    }
    const deploymentCommand = `(cd ${process.env.DEPLOYMENT_PATH}/${projectId} && ${runCommand})`;
    try {
        const { out: execOut, code: execCode } = await execOnHost(deploymentCommand, timeoutms, async (data: string) => {
            await sendLogToControlPlane(logId, data, DeploymentState.DEPLOYING);
        });
        if (execCode !== 0) {
            throw new Error(`Deployment command exited with code ${execCode}: ${execOut}`);
        }
        await sendLogToControlPlane(logId, 'Deployment command completed successfully.\n', DeploymentState.DEPLOYING);
    } catch (e: any) {
        throw new Error(`Error running deployment command: ${e.message}`);
    }
};
